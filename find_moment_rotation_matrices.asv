function M = find_moment_rotation_matrices()
    %assumed that M is centered first.
    
    %going to have to find a n^2 x n? matrix N such that:
    % reshape(N*thetavec, [n n]) * v = rv
    % thetavec = [sin(a); cos(a); sin(b); cos(b); sin(c); cos(c); 1];
    
    C = lash_constants;
    
        
%         Q = [1 0 0; 0 cos(t(1)) -sin(t(1)); 0 sin(t(1)) cos(t(1))] * ...
%             [cos(t(3)) -sin(t(3)) 0; sin(t(3)) cos(t(3)) 0; 0 0 1] * ...
%             [cos(t(2)) 0 sin(t(2)); 0 1 0; -sin(t(2)) 0 cos(t(2))];

    
    %find 2d rotation about z
    coeffs = coefficient_powers(2, C.moment_depth_generation);
    coeff_order = sum(coeffs,2);
    
    order_mat = zeros(length(coeff_order));
    
    for n = 1:C.moment_depth_generation
        order_mat = order_mat + ((coeff_order==n)*n)*(coeff_order==n)';
    end
    
    num_samples = 2;

    temp_mats = cell(C.moment_depth_generation,1);
    
    sincos_powers = [];
    for n = 1:C.moment_depth_generation
        tic
        num_M_of_order = sum(order_mat(:)==n);
        
        rs = ones(n+1, (n+1)*num_M_of_order);
        Ms = ones(num_M_of_order, (n+1)*num_M_of_order);
        
        my_sincos_powers = zeros(n+1,2);
        for l = 0:n
            my_sincos_powers(l+1,:) = [l, n-1];
        end
        sincos_powers = [sincos_powers; my_sincos_powers];
        
        for k = 1:(n+1)*num_M_of_order
            r = rand*pi;
            rs(:, k) = (sin(r).^my_sincos_powers(:,1))*(cos(r).^my_sincos_powers(:,2));
            for l = 0:n
                rs(l+1, k) = sin(r)^l*cos(r)^(n-l);
            end
            M = find_rotation_by_brute_force(r, coeffs, num_samples);  
            Ms(:,k) = M(order_mat(:)==n);
        end
        %X * rs = M
        
        temp_mats{n} = round(Ms / rs);
        toc;
    end
    
    
    num_adds = 0;
    for n = 1:C.moment_depth_generation
        num_adds = max([num_adds; sum(temp_mats{n}~=0,2)]);
    end
    
    rotM2d = zeros([num_adds, 3, size(M)]);
    
    for n = 1:C.moment_depth_generation
        %split into additions
        inds_in_M = find(order_mat==n);
        for k = 1:size(temp_mats{n},1)
            for l = 1:num_adds
                fI = find(temp_mats{n}(k,:),1,'first');
                if isempty(fI)
                    break
                end
                fV = temp_mats{n}(k,fI);
                temp_mats{n}(k,fI) = 0;
                rotM2d(l, 1, inds_in_M(k)) = fV;
                rotM2d(l, 2, inds_in_M(k)) = fI-1;
                rotM2d(l, 3, inds_in_M(k)) = n+1-fI;
                
            end
        end
    end
    rotM2d = rotM2d          
    
    r = rand*2;
    M = find_rotation_by_brute_force(r, coeffs, num_samples);   
    
    

    toc

    %M*q = Ms
%     M = Ms / q;
        
end
        

function M = find_rotation_by_brute_force(theta, coeffs, num_samples)
    
    moment_length = size(coeffs,1);
    
    Q = [cos(theta), -sin(theta); sin(theta), cos(theta)];
        
    invec = zeros(moment_length, moment_length);
    outvec = zeros(moment_length, moment_length);

    
    for k = 1:moment_length
        for l = 1:num_samples
            r = randn(2,1);
            invec(:,k) = invec(:,k) + r(1).^coeffs(:,1) .* r(2).^coeffs(:,2);
            r = Q*r;
            outvec(:,k) = outvec(:,k) + r(1).^coeffs(:,1) .* r(2).^coeffs(:,2);
        end
    end
    
    invec = invec/num_samples;
    outvec = outvec/num_samples;
        
        %M*iv = ov
    M = outvec / invec;
end
    
    